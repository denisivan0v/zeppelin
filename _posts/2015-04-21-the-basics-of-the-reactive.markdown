---
layout: post
title:  "The basics of the reactive"
date:   2015-04-23 22:00:00
isStaticPost: false
categories: [reactive manifesto observable]
---

#### Reactive manifesto

Начать изучение reactive programming как подхода к программированию, конечно же, стоит с [reactive manifesto](http://www.reactivemanifesto.org/). Этот документ объясняет базовые концепции, которые лежат в основе реактивного программирования. Или даже лучше сказать, свойства системы, которые хочется достичь.

Тут я не буду пересказывать подробно весь документ, поэтому настоятельно рекомендую его к самостоятельному прочтению. Однако, приведу самые важные части в качестве основы для дальнейшего описания.

Итак, reactive manifesto говорит нам, что мир быстро меняется и на смену системам, работающих на десяти серверах, отвечающих за секунды, оперирующими гигабайтами данных и недоступными часами в моменты обслуживания, приходят системы, развернутые на всем, чем только можно, начиная с мобильных устройств и заканчивая облаками, работающие на сотнях многоядерных процессорах и оперирующих петабайтами, притом, что отклик должен измеряться миллисекундами. Ну и вслед на этим должны меняться наши подходы к построению таких систем. 

Мы хотим, как утверждается в манифесте, строить системы, обладающие свойствами Отзывчивости (Responsive), Упругости (Resilient), Эластичности (Elastic) и Управления с помощью сообщений (Message Driven). Собственно, такие системы и есть Reactive systems.

Рассмотрим вкратце каждое свойство:

* **Responsive**: система отвечает очень быстро, и это время ответа, находясь в определенных границах, не выходит за верхний предел. Тем самым достигается постоянное *качество обслуживания (quality of service)*

* **Resilient**: система отвечает даже в момент сбоя. Это достигается за счет [репликации](http://www.reactivemanifesto.org/glossary#Replication), локальности, [изоляции](http://www.reactivemanifesto.org/glossary#Isolation) и [делегирования](http://www.reactivemanifesto.org/glossary#Delegation). Сбои локализуются внутри компонента, тем самым могут быть восстановлены отдельно, не влияя не систему в целом. Восстановлением занимается отдельный компонент.

* **Elastic**: система отвечает под изменяющейся нагрузкой. Реактивные системы могут увеличивать или уменьшать свои [ресурсы](http://www.reactivemanifesto.org/glossary#Resource). Дизайн системы построен так, чтобы не допускать неоднозначного поведения или центральных узлов-bottleneck-ов, что позволяет распределять входящую нагрузку. Реактивные системы поддерживают алгоритмы масштабирования, измеряя производительность в реальном времени.

* **Message Driven**: все основано на [асинхронной (неблокирующей)](http://www.reactivemanifesto.org/glossary#Asynchronous) [передаче сообщений](http://www.reactivemanifesto.org/glossary#Message-Driven), позволяя тем самым прочертить границы между компонентами и достичь слабой связанности, изоляции, независимости от [расположения компонентов (location transparency)](http://www.reactivemanifesto.org/glossary#Location-Transparency), а также воспринимать ошибки тоже как сообщения.

Вот как эти свойства связаны:

![image](http://www.reactivemanifesto.org/images/reactive-traits.svg)

Далее, небольшие системы складываются в большие, которые также сохраняют эти Реактивные свойства на всех уровнях масштабирования. 

Также рекемендую почитать [глоссарий терминов](http://www.reactivemanifesto.org/glossary) и подписать манифест, если вы со всем согласны. Если не согласны - давайте обсудим это в комментариях.

#### Observable